/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-get.m2c
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "applTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement applTable get routines.
 * TODO:240:M: Implement applTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table applTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * NETWORK-SERVICES-MIB::applTable is subid 1 of application.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.27.1, length: 8
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement applTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param applIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
applTable_indexes_set_tbl_idx(applTable_mib_index * tbl_idx,
                              long applIndex_val)
{
    DEBUGMSGTL(("verbose:applTable:applTable_indexes_set_tbl_idx",
                "called\n"));

    /*
     * applIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/a/w/e/R/d/h 
     */
    tbl_idx->applIndex = applIndex_val;


    return MFD_SUCCESS;
}                               /* applTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
applTable_indexes_set(applTable_rowreq_ctx * rowreq_ctx,
                      long applIndex_val)
{
    DEBUGMSGTL(("verbose:applTable:applTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        applTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, applIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != applTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* applTable_indexes_set */


/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applName
 * applName is subid 2 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.2
 * Description:
The name the network service application chooses to be
       known by.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255t
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the applName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param applName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by applName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*applName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update applName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
applName_get(applTable_rowreq_ctx * rowreq_ctx,
             char **applName_val_ptr_ptr, size_t *applName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != applName_val_ptr_ptr)
                   && (NULL != *applName_val_ptr_ptr));
    netsnmp_assert(NULL != applName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:applTable:applName_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applName data.
     * copy (* applName_val_ptr_ptr ) data and (* applName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for applName data
     */
    if ((NULL == (*applName_val_ptr_ptr)) ||
        ((*applName_val_ptr_len_ptr) <
         (rowreq_ctx->data.applName_len *
          sizeof(rowreq_ctx->data.applName[0])))) {
        /*
         * allocate space for applName data
         */
        (*applName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.applName_len *
                   sizeof(rowreq_ctx->data.applName[0]));
        if (NULL == (*applName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.applName)\n");
            return MFD_ERROR;
        }
    }
    (*applName_val_ptr_len_ptr) =
        rowreq_ctx->data.applName_len *
        sizeof(rowreq_ctx->data.applName[0]);
    memcpy((*applName_val_ptr_ptr), rowreq_ctx->data.applName,
           rowreq_ctx->data.applName_len *
           sizeof(rowreq_ctx->data.applName[0]));

    return MFD_SUCCESS;
}                               /* applName_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applDirectoryName
 * applDirectoryName is subid 3 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.3
 * Description:
The Distinguished Name of the directory entry where
       static information about this application is stored.
       An empty string indicates that no information about
       the application is available in the directory.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DistinguishedName (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the applDirectoryName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applDirectoryName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param applDirectoryName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by applDirectoryName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*applDirectoryName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update applDirectoryName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
applDirectoryName_get(applTable_rowreq_ctx * rowreq_ctx,
                      char **applDirectoryName_val_ptr_ptr,
                      size_t *applDirectoryName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != applDirectoryName_val_ptr_ptr)
                   && (NULL != *applDirectoryName_val_ptr_ptr));
    netsnmp_assert(NULL != applDirectoryName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:applTable:applDirectoryName_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applDirectoryName data.
     * copy (* applDirectoryName_val_ptr_ptr ) data and (* applDirectoryName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for applDirectoryName data
     */
    if ((NULL == (*applDirectoryName_val_ptr_ptr)) ||
        ((*applDirectoryName_val_ptr_len_ptr) <
         (rowreq_ctx->data.applDirectoryName_len *
          sizeof(rowreq_ctx->data.applDirectoryName[0])))) {
        /*
         * allocate space for applDirectoryName data
         */
        (*applDirectoryName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.applDirectoryName_len *
                   sizeof(rowreq_ctx->data.applDirectoryName[0]));
        if (NULL == (*applDirectoryName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.applDirectoryName)\n");
            return MFD_ERROR;
        }
    }
    (*applDirectoryName_val_ptr_len_ptr) =
        rowreq_ctx->data.applDirectoryName_len *
        sizeof(rowreq_ctx->data.applDirectoryName[0]);
    memcpy((*applDirectoryName_val_ptr_ptr),
           rowreq_ctx->data.applDirectoryName,
           rowreq_ctx->data.applDirectoryName_len *
           sizeof(rowreq_ctx->data.applDirectoryName[0]));

    return MFD_SUCCESS;
}                               /* applDirectoryName_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applVersion
 * applVersion is subid 4 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.4
 * Description:
The version of network service application software.
       This field is usually defined by the vendor of the
       network service application software.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255t
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the applVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applVersion_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param applVersion_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by applVersion.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*applVersion_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update applVersion_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
applVersion_get(applTable_rowreq_ctx * rowreq_ctx,
                char **applVersion_val_ptr_ptr,
                size_t *applVersion_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != applVersion_val_ptr_ptr)
                   && (NULL != *applVersion_val_ptr_ptr));
    netsnmp_assert(NULL != applVersion_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:applTable:applVersion_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applVersion data.
     * copy (* applVersion_val_ptr_ptr ) data and (* applVersion_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for applVersion data
     */
    if ((NULL == (*applVersion_val_ptr_ptr)) ||
        ((*applVersion_val_ptr_len_ptr) <
         (rowreq_ctx->data.applVersion_len *
          sizeof(rowreq_ctx->data.applVersion[0])))) {
        /*
         * allocate space for applVersion data
         */
        (*applVersion_val_ptr_ptr) =
            malloc(rowreq_ctx->data.applVersion_len *
                   sizeof(rowreq_ctx->data.applVersion[0]));
        if (NULL == (*applVersion_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.applVersion)\n");
            return MFD_ERROR;
        }
    }
    (*applVersion_val_ptr_len_ptr) =
        rowreq_ctx->data.applVersion_len *
        sizeof(rowreq_ctx->data.applVersion[0]);
    memcpy((*applVersion_val_ptr_ptr), rowreq_ctx->data.applVersion,
           rowreq_ctx->data.applVersion_len *
           sizeof(rowreq_ctx->data.applVersion[0]));

    return MFD_SUCCESS;
}                               /* applVersion_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applUptime
 * applUptime is subid 5 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.5
 * Description:
The value of sysUpTime at the time the network service
       application was last initialized.  If the application was
       last initialized prior to the last initialization of the
       network management subsystem, then this object contains
       a zero value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applUptime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applUptime_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applUptime_get(applTable_rowreq_ctx * rowreq_ctx,
               u_long * applUptime_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applUptime_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applUptime_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applUptime data.
     * copy (* applUptime_val_ptr ) from rowreq_ctx->data
     */
    (*applUptime_val_ptr) = rowreq_ctx->data.applUptime;

    return MFD_SUCCESS;
}                               /* applUptime_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applOperStatus
 * applOperStatus is subid 6 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.6
 * Description:
Indicates the operational status of the network service
       application. 'down' indicates that the network service is

       not available. 'up' indicates that the network service
       is operational and available.  'halted' indicates that the
       service is operational but not available.  'congested'
       indicates that the service is operational but no additional
       inbound associations can be accommodated.  'restarting'
       indicates that the service is currently unavailable but is
       in the process of restarting and will be available soon.
       'quiescing' indicates that service is currently operational
       but is in the process of shutting down. Additional inbound
       associations may be rejected by applications in the
       'quiescing' state.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 6. Values:  up(1), down(2), halted(3), congested(4), restarting(5), quiescing(6)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the applOperStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applOperStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applOperStatus_get(applTable_rowreq_ctx * rowreq_ctx,
                   u_long * applOperStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applOperStatus_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applOperStatus_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applOperStatus data.
     * copy (* applOperStatus_val_ptr ) from rowreq_ctx->data
     */
    (*applOperStatus_val_ptr) = rowreq_ctx->data.applOperStatus;

    return MFD_SUCCESS;
}                               /* applOperStatus_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applLastChange
 * applLastChange is subid 7 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.7
 * Description:
The value of sysUpTime at the time the network service
       application entered its current operational state.  If
       the current state was entered prior to the last
       initialization of the local network management subsystem,
       then this object contains a zero value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applLastChange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applLastChange_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applLastChange_get(applTable_rowreq_ctx * rowreq_ctx,
                   u_long * applLastChange_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applLastChange_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applLastChange_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applLastChange data.
     * copy (* applLastChange_val_ptr ) from rowreq_ctx->data
     */
    (*applLastChange_val_ptr) = rowreq_ctx->data.applLastChange;

    return MFD_SUCCESS;
}                               /* applLastChange_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applInboundAssociations
 * applInboundAssociations is subid 8 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.8
 * Description:
The number of current associations to the network service
       application, where it is the responder.  An inbound
       association occurs when another application successfully
       connects to this one.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applInboundAssociations data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applInboundAssociations_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applInboundAssociations_get(applTable_rowreq_ctx * rowreq_ctx,
                            u_long * applInboundAssociations_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applInboundAssociations_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applInboundAssociations_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applInboundAssociations data.
     * copy (* applInboundAssociations_val_ptr ) from rowreq_ctx->data
     */
    (*applInboundAssociations_val_ptr) =
        rowreq_ctx->data.applInboundAssociations;

    return MFD_SUCCESS;
}                               /* applInboundAssociations_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applOutboundAssociations
 * applOutboundAssociations is subid 9 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.9
 * Description:
The number of current associations to the network service
       application, where it is the initiator.  An outbound
       association occurs when this application successfully
       connects to another one.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applOutboundAssociations data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applOutboundAssociations_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applOutboundAssociations_get(applTable_rowreq_ctx * rowreq_ctx,
                             u_long * applOutboundAssociations_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applOutboundAssociations_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applOutboundAssociations_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applOutboundAssociations data.
     * copy (* applOutboundAssociations_val_ptr ) from rowreq_ctx->data
     */
    (*applOutboundAssociations_val_ptr) =
        rowreq_ctx->data.applOutboundAssociations;

    return MFD_SUCCESS;
}                               /* applOutboundAssociations_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applAccumulatedInboundAssociations
 * applAccumulatedInboundAssociations is subid 10 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.10
 * Description:
The total number of associations to the application entity
       since application initialization, where it was the responder.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applAccumulatedInboundAssociations data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applAccumulatedInboundAssociations_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applAccumulatedInboundAssociations_get(applTable_rowreq_ctx * rowreq_ctx,
                                       u_long *
                                       applAccumulatedInboundAssociations_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applAccumulatedInboundAssociations_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applAccumulatedInboundAssociations_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applAccumulatedInboundAssociations data.
     * copy (* applAccumulatedInboundAssociations_val_ptr ) from rowreq_ctx->data
     */
    (*applAccumulatedInboundAssociations_val_ptr) =
        rowreq_ctx->data.applAccumulatedInboundAssociations;

    return MFD_SUCCESS;
}                               /* applAccumulatedInboundAssociations_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applAccumulatedOutboundAssociations
 * applAccumulatedOutboundAssociations is subid 11 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.11
 * Description:
The total number of associations to the application entity
       since application initialization, where it was the initiator.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applAccumulatedOutboundAssociations data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applAccumulatedOutboundAssociations_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applAccumulatedOutboundAssociations_get(applTable_rowreq_ctx * rowreq_ctx,
                                        u_long *
                                        applAccumulatedOutboundAssociations_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applAccumulatedOutboundAssociations_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applAccumulatedOutboundAssociations_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applAccumulatedOutboundAssociations data.
     * copy (* applAccumulatedOutboundAssociations_val_ptr ) from rowreq_ctx->data
     */
    (*applAccumulatedOutboundAssociations_val_ptr) =
        rowreq_ctx->data.applAccumulatedOutboundAssociations;

    return MFD_SUCCESS;
}                               /* applAccumulatedOutboundAssociations_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applLastInboundActivity
 * applLastInboundActivity is subid 12 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.12
 * Description:
The value of sysUpTime at the time this application last
       had an inbound association.  If the last association
       occurred prior to the last initialization of the network
       subsystem, then this object contains a zero value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applLastInboundActivity data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applLastInboundActivity_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applLastInboundActivity_get(applTable_rowreq_ctx * rowreq_ctx,
                            u_long * applLastInboundActivity_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applLastInboundActivity_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applLastInboundActivity_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applLastInboundActivity data.
     * copy (* applLastInboundActivity_val_ptr ) from rowreq_ctx->data
     */
    (*applLastInboundActivity_val_ptr) =
        rowreq_ctx->data.applLastInboundActivity;

    return MFD_SUCCESS;
}                               /* applLastInboundActivity_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applLastOutboundActivity
 * applLastOutboundActivity is subid 13 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.13
 * Description:
The value of sysUpTime at the time this application last
       had an outbound association.  If the last association
       occurred prior to the last initialization of the network
       subsystem, then this object contains a zero value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applLastOutboundActivity data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applLastOutboundActivity_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applLastOutboundActivity_get(applTable_rowreq_ctx * rowreq_ctx,
                             u_long * applLastOutboundActivity_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applLastOutboundActivity_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applLastOutboundActivity_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applLastOutboundActivity data.
     * copy (* applLastOutboundActivity_val_ptr ) from rowreq_ctx->data
     */
    (*applLastOutboundActivity_val_ptr) =
        rowreq_ctx->data.applLastOutboundActivity;

    return MFD_SUCCESS;
}                               /* applLastOutboundActivity_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applRejectedInboundAssociations
 * applRejectedInboundAssociations is subid 14 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.14
 * Description:
The total number of inbound associations the application
       entity has rejected, since application initialization.
       Rejected associations are not counted in the accumulated
       association totals.  Note that this only counts

       associations the application entity has rejected itself;
       it does not count rejections that occur at lower layers
       of the network.  Thus, this counter may not reflect the
       true number of failed inbound associations.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applRejectedInboundAssociations data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applRejectedInboundAssociations_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applRejectedInboundAssociations_get(applTable_rowreq_ctx * rowreq_ctx,
                                    u_long *
                                    applRejectedInboundAssociations_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applRejectedInboundAssociations_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applRejectedInboundAssociations_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applRejectedInboundAssociations data.
     * copy (* applRejectedInboundAssociations_val_ptr ) from rowreq_ctx->data
     */
    (*applRejectedInboundAssociations_val_ptr) =
        rowreq_ctx->data.applRejectedInboundAssociations;

    return MFD_SUCCESS;
}                               /* applRejectedInboundAssociations_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applFailedOutboundAssociations
 * applFailedOutboundAssociations is subid 15 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.15
 * Description:
The total number associations where the application entity
       is initiator and association establishment has failed,
       since application initialization.  Failed associations are
       not counted in the accumulated association totals.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the applFailedOutboundAssociations data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applFailedOutboundAssociations_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
applFailedOutboundAssociations_get(applTable_rowreq_ctx * rowreq_ctx,
                                   u_long *
                                   applFailedOutboundAssociations_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != applFailedOutboundAssociations_val_ptr);


    DEBUGMSGTL(("verbose:applTable:applFailedOutboundAssociations_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applFailedOutboundAssociations data.
     * copy (* applFailedOutboundAssociations_val_ptr ) from rowreq_ctx->data
     */
    (*applFailedOutboundAssociations_val_ptr) =
        rowreq_ctx->data.applFailedOutboundAssociations;

    return MFD_SUCCESS;
}                               /* applFailedOutboundAssociations_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applDescription
 * applDescription is subid 16 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.16
 * Description:
A text description of the application.  This information
       is intended to identify and briefly describe the
       application in a status display.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255t
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the applDescription data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applDescription_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param applDescription_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by applDescription.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*applDescription_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update applDescription_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
applDescription_get(applTable_rowreq_ctx * rowreq_ctx,
                    char **applDescription_val_ptr_ptr,
                    size_t *applDescription_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != applDescription_val_ptr_ptr)
                   && (NULL != *applDescription_val_ptr_ptr));
    netsnmp_assert(NULL != applDescription_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:applTable:applDescription_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applDescription data.
     * copy (* applDescription_val_ptr_ptr ) data and (* applDescription_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for applDescription data
     */
    if ((NULL == (*applDescription_val_ptr_ptr)) ||
        ((*applDescription_val_ptr_len_ptr) <
         (rowreq_ctx->data.applDescription_len *
          sizeof(rowreq_ctx->data.applDescription[0])))) {
        /*
         * allocate space for applDescription data
         */
        (*applDescription_val_ptr_ptr) =
            malloc(rowreq_ctx->data.applDescription_len *
                   sizeof(rowreq_ctx->data.applDescription[0]));
        if (NULL == (*applDescription_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.applDescription)\n");
            return MFD_ERROR;
        }
    }
    (*applDescription_val_ptr_len_ptr) =
        rowreq_ctx->data.applDescription_len *
        sizeof(rowreq_ctx->data.applDescription[0]);
    memcpy((*applDescription_val_ptr_ptr),
           rowreq_ctx->data.applDescription,
           rowreq_ctx->data.applDescription_len *
           sizeof(rowreq_ctx->data.applDescription[0]));

    return MFD_SUCCESS;
}                               /* applDescription_get */

/*---------------------------------------------------------------------
 * NETWORK-SERVICES-MIB::applEntry.applURL
 * applURL is subid 17 of applEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.27.1.1.17
 * Description:
A URL pointing to a description of the application.
       This information is intended to identify and describe
       the application in a status display.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is URLString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the applURL data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param applURL_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param applURL_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by applURL.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*applURL_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update applURL_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
applURL_get(applTable_rowreq_ctx * rowreq_ctx, char **applURL_val_ptr_ptr,
            size_t *applURL_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != applURL_val_ptr_ptr)
                   && (NULL != *applURL_val_ptr_ptr));
    netsnmp_assert(NULL != applURL_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:applTable:applURL_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the applURL data.
     * copy (* applURL_val_ptr_ptr ) data and (* applURL_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for applURL data
     */
    if ((NULL == (*applURL_val_ptr_ptr)) ||
        ((*applURL_val_ptr_len_ptr) <
         (rowreq_ctx->data.applURL_len *
          sizeof(rowreq_ctx->data.applURL[0])))) {
        /*
         * allocate space for applURL data
         */
        (*applURL_val_ptr_ptr) =
            malloc(rowreq_ctx->data.applURL_len *
                   sizeof(rowreq_ctx->data.applURL[0]));
        if (NULL == (*applURL_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.applURL)\n");
            return MFD_ERROR;
        }
    }
    (*applURL_val_ptr_len_ptr) =
        rowreq_ctx->data.applURL_len * sizeof(rowreq_ctx->data.applURL[0]);
    memcpy((*applURL_val_ptr_ptr), rowreq_ctx->data.applURL,
           rowreq_ctx->data.applURL_len *
           sizeof(rowreq_ctx->data.applURL[0]));

    return MFD_SUCCESS;
}                               /* applURL_get */



/** @} */
